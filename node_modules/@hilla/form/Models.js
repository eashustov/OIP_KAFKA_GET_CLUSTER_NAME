// TODO: Fix dependency cycle
var _a, _b, _c, _d, _e, _f, _g, _h, _j;
import isNumeric from 'validator/es/lib/isNumeric.js';
// eslint-disable-next-line import/no-cycle
import { BinderNode } from './BinderNode.js';
import { IsNumber } from './Validators.js';
export const _ItemModel = Symbol('ItemModel');
export const _parent = Symbol('parent');
export const _key = Symbol('key');
export const _fromString = Symbol('fromString');
export const _validators = Symbol('validators');
export const _binderNode = Symbol('binderNode');
export const _getPropertyModel = Symbol('getPropertyModel');
const _properties = Symbol('properties');
const _optional = Symbol('optional');
export function getBinderNode(model) {
    if (!model[_binderNode]) {
        model[_binderNode] = new BinderNode(model);
    }
    return model[_binderNode];
}
export class AbstractModel {
    constructor(parent, key, optional, ...validators) {
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _d, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _e, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this[_parent] = parent;
        this[_key] = key;
        this[_optional] = optional;
        this[_validators] = validators;
    }
    static createEmptyValue() {
        return undefined;
    }
    toString() {
        return String(this.valueOf());
    }
    valueOf() {
        const { value } = getBinderNode(this);
        if (value === undefined) {
            throw new TypeError('Value is undefined');
        }
        return value;
    }
}
_a = _parent, _b = _validators, _c = _optional, _d = _binderNode, _e = _key;
export class PrimitiveModel extends AbstractModel {
}
export class BooleanModel extends PrimitiveModel {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, _f, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: Boolean
        });
    }
}
_f = _fromString;
Object.defineProperty(BooleanModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Boolean
});
export class NumberModel extends PrimitiveModel {
    constructor(parent, key, optional, ...validators) {
        // Prepend a built-in validator to indicate NaN input
        super(parent, key, optional, new IsNumber(optional), ...validators);
    }
    [_fromString](str) {
        // Returning undefined is needed to support passing the validation when the value of an optional number field is
        // an empty string
        if (str === '')
            return undefined;
        return isNumeric(str) ? Number.parseFloat(str) : NaN;
    }
}
Object.defineProperty(NumberModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Number
});
export class StringModel extends PrimitiveModel {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, _g, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: String
        });
    }
}
_g = _fromString;
Object.defineProperty(StringModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: String
});
export class ObjectModel extends AbstractModel {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, _h, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    static createEmptyValue() {
        const modelInstance = new this({ value: undefined }, 'value', false);
        let obj = {};
        // Iterate the model class hierarchy up to the ObjectModel, and extract
        // the property getter names from every prototypes
        for (let proto = Object.getPrototypeOf(modelInstance); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
            obj = Object.getOwnPropertyNames(proto)
                .filter((propertyName) => propertyName !== 'constructor')
                // Initialise the properties in the value object with empty value
                .reduce((o, propertyName) => {
                const propertyModel = modelInstance[propertyName];
                o[propertyName] = propertyModel[_optional]
                    ? undefined
                    : propertyModel.constructor.createEmptyValue();
                return o;
            }, obj);
        }
        return obj;
    }
    [(_h = _properties, _getPropertyModel)](name, ValueModel, valueModelArgs) {
        const [optional, ...rest] = valueModelArgs;
        if (this[_properties][name] === undefined) {
            this[_properties][name] = new ValueModel(this, name, optional, ...rest);
        }
        return this[_properties][name];
    }
}
export class ArrayModel extends AbstractModel {
    constructor(parent, key, optional, ItemModel, itemModelArgs, ...validators) {
        super(parent, key, optional, ...validators);
        Object.defineProperty(this, _j, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "itemModelArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "itemModels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this[_ItemModel] = ItemModel;
        this.itemModelArgs = itemModelArgs;
    }
    static createEmptyValue() {
        return [];
    }
    /**
     * Iterates the current array value and yields a binder node for every item.
     */
    *[(_j = _ItemModel, Symbol.iterator)]() {
        const array = this.valueOf();
        const ItemModel = this[_ItemModel];
        if (array.length !== this.itemModels.length) {
            this.itemModels.length = array.length;
        }
        for (const i of array.keys()) {
            let itemModel = this.itemModels[i];
            if (!itemModel) {
                const [optional, ...rest] = this.itemModelArgs;
                itemModel = new ItemModel(this, i, optional, ...rest);
                this.itemModels[i] = itemModel;
            }
            yield getBinderNode(itemModel);
        }
    }
}
//# sourceMappingURL=Models.js.map